# 쿼리 분석 및 인덱스 필요성 평가

# 1. 인덱스가 필요해 보이는 쿼리

## 1.1 Concert Service

### 1.1.1 콘서트 스케줄 조회 쿼리

```Java
ConcertScheduleRepository.findAllByConcertId(Long concertId)
```
- 기능: 특정 콘서트의 모든 스케줄을 조회한다.
- 실제 생성되는 SQL:
    ```sql
    SELECT cs.* FROM concertSchedules cs WHERE cs.concert_id = ?
    ```

- 인덱스가 필요해 보이는 이유
  - 콘서트별 스케줄 조회가 자주 발생할 것으로 예상된다.
  - 사용자가 특정 콘서트의 일정을 조회하는 경우가 빈번할 것으로 예상한다.
  - 콘서트 수가 많아질수록 전체 스캔은 비효율적이므로, 인덱스가 콘서트 Id 로 필요하다고 판단했다.

- 인덱스 적용: `concert_id` 컬럼에 인덱스 적용
  - Cardinality 고려:
    - `concert_id` 컬럼은 중간에서 높은 Cardinality를 가질 것으로 예상된다.
    - 이 정도의 Cardinality는 인덱스의 효율성을 상당히 높여줄 수 있다. 특정 콘서트의 스케줄을 조회할 때 데이터베이스는 인덱스를 통해 해당 콘서트의 스케줄들을 빠르게 찾을 수 있다.


- JPA를 사용한 방법
    ```Java
    @Entity
    @Table(name = "concertSchedules", indexes = @Index(name = "idx_concert_id", columnList = "concert_id"))
    public class ConcertSchedule
    ```

- DB에 직접 인덱스를 적용하는 방법:
    ```sql
    CREATE INDEX idx_concert_id ON concertSchedules (concert_id);
    ```

- 인덱스 적용으로 인한 기대효과
  - 특정 콘서트의 스케줄을 빠르게 조회할 수 있게 된다.
  - 콘서트 상세 페이지 로딩 시간이 크게 개선될 것으로 예상된다.


- 인덱스 적용 전과 후의 결과
  ```sql
  # 인덱스 적용 전
  
  +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
  +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  |  1 | SIMPLE      | cs        | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1500   |    10.00 | Using where |
  +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  ```
  - 전체 테이블 스캔 (type: ALL) 을 수행한다.
  - 조회해야 할 rows 가 1500 개다.

  ```sql
  # 인덱스 적용 후
  +----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+
  | id | select_type | table     | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra       |
  +----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+
  |  1 | SIMPLE      | cs        | NULL       | ref  | idx_concert_id   | idx_concert_id   | 8       | const | 3    |   100.00 | Using index |
  +----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+
  ```

  - 인덱스를 사용 (type: ref) 하여 빠르게 결과를 찾을 수 있다.
  - 인덱스를 적용 후 조회하는 rows 가 3개로 줄었다.

<br>

## 1.2 Reservation Service

### 1.2.1 유저별 예약 내역 조회 쿼리
```Java
ReservationGroupRepository.findAllByUserId(Long userId)
```

- 기능: 유저 Id로 해당 유저의 예약 내역을 조회한다.

- 실제 생성되는 SQL:
  ```sql
  SELECT rg.* FROM reservation_groups rg WHERE rg.user_id = ?
  ```

- 인덱스가 필요해 보이는 이유:
  - 예약별 결제 정보 조회가 자주 발생할 것으로 예상된다.
  - 예약 확인, 결제 상태 확인 등에서 빈번하게 사용될 수 있다.
  - 예약 수가 증가함에 따라 전체 스캔은 비효율적이다.


- 인덱스 적용: `user_id` 컬럼에 인덱스 적용
  - Cardinality 고려:
    - `user_id` 컬럼은 매우 높은 Cardinality를 가질 것으로 예상된다. 각 유저는 고유한 Id를 가지므로, 이 컬럼의 값들은 매우 다양할 것이다.
    - 높은 Cardinality는 인덱스 효율성을 극대화한다. 데이터베이스는 인덱스를 통해 특정 예약의 결제 정보를 매우 빠르게 찾을 수 있다.
    - 이는 B-트리 인덱스의 장점을 최대한 활용할 수 있게 해주어, 검색 성능을 크게 개선할 것이다.


- JPA를 사용한 방법:
    ```Java
    @Entity
    @Table(name = "reservation_groups", indexes = @Index(columnList = "user_id"))
    public class ReservationGroup {
    }
    ```


- DB에 직접 인덱스를 적용하는 방법:
  ```sql
  CREATE INDEX idx_user_id ON reservation_groups (user_id);
  ```

- 인덱스 적용으로 인한 기대효과:
  - 특정 예약의 결제 정보를 빠르게 조회할 수 있게 된다.
  - 예약 확인 페이지 로딩 시간이 개선될 것으로 예상된다.


- 인덱스 적용 전과 후의 결과

  ```sql
  # 인덱스 적용 전
  
  +----+-------------+--------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  | id | select_type | table              | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
  +----+-------------+--------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  |  1 | SIMPLE      | reservation_groups | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 500    |    10.00 | Using where |
  +----+-------------+--------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  
  ```
  - 전체 테이블 스캔 (type: ALL) 을 수행한다.
  - 조회해야 할 rows 가 500 개다.

  ```sql
  # 인덱스 적용 후
  +----+-------------+--------------------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+
  | id | select_type | table              | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra       |
  +----+-------------+--------------------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+
  |  1 | SIMPLE      | reservation_groups | NULL       | ref  | idx_user_id   | idx_user_id   | 8       | const | 103  |   100.00 | Using index |
  +----+-------------+--------------------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+
  ```
  - 인덱스를 사용 (type: ref) 하여 빠르게 결과를 찾을 수 있다.
  - 인덱스를 적용 후 조회하는 rows 가 103개로 줄었다.

<br>

### 1.2.2 예약 그룹 별 예약 목록 조회 쿼리

```Java
ReservationRepository.findAllByReservationGroupId(Long reservationGroupId)
```

- 기능: 예약 그룹에 속해있는 예약들의 목록을 조회 
- 실제 생성되는 SQL:
  ```sql
  SELECT r.* FROM reservations r WHERE r.reservation_group_id = ?
  ````

- 인덱스가 필요해 보이는 이유:
  - 예약 Id를 통해 각각의 예약을 조회하는 것보다 예약 그룹 Id로 예약 그룹에 속해있는 예약을 한꺼번에 조회하는 일이 많을 것으로 판단했다.
  - 대량의 예약 데이터에서 조건에 맞는 레코드를 빠르게 찾아야 한다.

- 인덱스 적용: `reservation_group_id` 컬럼에 인덱스 적용
  - Cardinality 고려:
    - `reservation_group_id` 컬럼은 높은 Cardinality를 가진다 (각 예약 그룹마다 고유한 예약 그룹 Id 가짐).
    - 이 정도의 Cardinality는 인덱스의 효율성을 상당히 높여줄 수 있다. 유저가 예약들의 상태를 조회하고 싶을 때 데이터베이스는 인덱스를 통해 해당 유저의 예약목록을 빠르게 찾을 수 있다.
- JPA를 사용한 방법:
  ```Java
  @Entity
  @Table(name = "reservations", indexes = @Index(name = "idx_rg_id", columnList = "reservation_group_id"))
  public class Reservation{

  }
  
  ```

- DB에 직접 인덱스를 적용하는 방법:
  ```sql
  CREATE INDEX idx_rg_id ON reservations (reservation_group_id);
  ```

- 인덱스 적용으로 인한 기대효과
  - 만료된 예약을 빠르게 조회할 수 있게 된다.
  - 스케쥴러 작업의 성능이 크게 개선될 것으로 예상된다.

- 인덱스 적용 전과 후의 결과

  ```sql
  # 인덱스 적용 전
  
  +----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
  +----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  |  1 | SIMPLE      | r       | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   1500 |     5.00 | Using where |
  +----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  
  ```
  - 전체 테이블 스캔 (type: ALL) 을 수행한다.
  - 조회해야 할 rows 가 1500 개다.

  ```sql
  # 인덱스 적용 후
  +----+-------------+---------+------------+-------+---------------+------------+---------+------+-------+----------+-------------+
  | id | select_type | table   | partitions | type  | possible_keys | key        | key_len | ref  | rows  | filtered | Extra       |
  +----+-------------+---------+------------+-------+---------------+------------+---------+------+-------+----------+-------------+
  |  1 | SIMPLE      | r       | NULL       | range | idx_rg_id     | idx_rg_id  | 8       | NULL |     3 |   100.00 | Using where |
  +----+-------------+---------+------------+-------+---------------+------------+---------+------+-------+----------+-------------+
  ```

  - 인덱스를 사용 (type: ref) 하여 빠르게 결과를 찾을 수 있다.
  - 인덱스를 적용 후 조회하는 rows 가 3개로 줄었다.

<br>

## 1.3 Seat Service

### 1.3.1 콘서트 스케줄별 좌석 조회 쿼리
  ```Java
  SeatJpaRepository.findAllByScheduleId(scheduleId: Long)
  ```

- 기능: 특정 콘서트 스케줄의 모든 좌석을 조회한다.

- 실제 생성되는 SQL
  ```sql
  SELECT s.* FROM seats s WHERE s.concert_schedule_id = ?
  ```

- 인덱스가 필요해 보이는 이유:
  - 스케줄별 좌석 조회가 빈번할 것으로 예상된다.
  - 사용자가 특정 공연의 좌석 현황을 조회할 때 자주 사용될 것으로 예상한다.
  - 대규모 공연장의 경우 좌석 수가 많아 전체 스캔은 비효율적이다.


- 인덱스 적용: `concert_schedule_id` 컬럼에 인덱스 적용
  - Cardinality 고려:
    - `concert_schedule_id` 컬럼은 높은 Cardinality를 가질 것으로 예상된다.
    - 이러한 높은 Cardinality는 인덱스의 효율성을 크게 향상시킨다. 데이터베이스는 인덱스를 통해 특정 스케줄의 좌석들을 매우 빠르게 찾을 수 있다.
    - B-트리 인덱스의 특성을 고려할 때, 이 정도의 Cardinality에서는 검색 성능이 대폭 개선될 것으로 예상된다.

- JPA를 사용한 방법:
  ```Java
  @Entity
  @Table(name = "seat", indexes = [@Index(columnList = "concert_schedule_id")])
  class Seat {
  }
  ```

- DB에 직접 인덱스를 적용하는 방법
  ```sql
  CREATE INDEX idx_concert_schedule_id ON seats (concert_schedule_id);
  ```

- 인덱스 적용으로 인한 기대효과:
  - 특정 콘서트 스케줄의 좌석을 빠르게 조회할 수 있게 된다.
  - 좌석 선택 페이지의 로딩 시간이 크게 개선될 것으로 예상된다.


- 인덱스 적용 전과 후의 결과

  ```sql
  # 인덱스 적용 전
  
  +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  | id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
  +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  |  1 | SIMPLE      | seats  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9000   |    10.00 | Using where |
  +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  
  ```
  - 전체 테이블 스캔 (type: ALL) 을 수행한다.
  - 조회해야 할 rows 가 9000 개다.

  ```sql
  # 인덱스 적용 후
  +----+-------------+--------+------------+------+---------------------------+---------------------------+---------+-------+------+----------+-------------+
  | id | select_type | table  | partitions | type | possible_keys             | key                       | key_len | ref   | rows | filtered | Extra       |
  +----+-------------+--------+------------+------+---------------------------+---------------------------+---------+-------+------+----------+-------------+
  |  1 | SIMPLE      | seats  | NULL       | ref  | idx_concert_schedule_id   | idx_concert_schedule_id   | 32      | const | 6    |   100.00 | Using index |
  +----+-------------+--------+------------+------+---------------------------+---------------------------+---------+-------+------+----------+-------------+
  ```

  - 인덱스를 사용 (type: ref) 하여 빠르게 결과를 찾을 수 있다.
  - 인덱스를 적용 후 조회하는 rows 가 6개로 줄었다.

### 1.3.2 예약 가능한 좌석 수 조회 쿼리
```Java
SeatRepository.countByConcertScheduleIdAndSeatStatus(Long concertScheduleId, SeatStatus seatStatus)
```
- 기능: 좌석 스케쥴에 해당하는 좌석 중 예약 가능 상태의 좌석 수를 조회한다.

- 실제 생성되는 SQL:
  ```sql
  SELECT COUNT(*) FROM seats WHERE concert_schedule_id = '1' AND seatStatus = 'AVAIABLE'
  ```

- 인덱스가 필요해 보이는 이유:
    - 콘서트의 스케쥴을 조회하는 과정에서 많은 요청이 발생할 것으로 예상된다.
    - 좌석 상태와 concertScheduleId를 함께 고려해야 하므로, 두가지를 조합한 복합 인덱스가 효과적일 것으로 판단했다.
    - 대량의 좌석 데이터에서 조건에 맞는 레코드를 빠르게 찾아야 한다.
    - 인덱스 적용: `seat_status` 와 `concert_schedule_id` 컬럼에 복합 인덱스 적용

- Cardinality 고려:
    - seat_status 컬럼은 낮은 Cardinality를 가질 것으로 예상된다 ('AVAILABLE', 'LOCKED', 'RESERVED' 세 가지 상태만 존재).
    - concert_schedule_id 컬럼은 높은 Cardinality를 가진다 (각 콘서트 스케쥴마다 고유한 Id을 가짐).
    - 복합 인덱스를 사용함으로써, 낮은 Cardinality의 seat_status 1차 필터링을 하고, 높은 Cardinality의 concert_schedule_id 2차 필터링을 수행하여 효율적인 검색이 가능하도록 한다.
    - 이러한 조합은 인덱스의 선택성(Selectivity)을 높여, 쿼리 성능을 최적화한다.

- JPA를 사용한 방법:
```Java
@Entity
@Table(name = "seats", indexes = @Index(name = "idx_status_cs_id", columnList = "seat_status, concert_schedule_id"))
public class Seat {

}
```

- DB에 직접 인덱스를 적용하는 방법:
```sql
CREATE INDEX idx_status_cs_id ON seats (seatStatus, concert_schedule_id);
```

- 인덱스 적용으로 인한 기대효과
    - 사용가능한 좌석을 빠르게 조회할 수 있게 된다.
    - 인덱스 적용 전과 후의 결과

    ```sql
    # 인덱스 적용 전
    +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | seats | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9000   |     5.00 | Using where |
    +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    ```
    - 전체 테이블 스캔 (type: ALL) 을 수행한다.
    - 조회해야 할 rows 가 9000 개다.

    ```sql
    # 인덱스 적용 후
    +----+-------------+-------+------------+-------+--------------------------------------------+-------------------+---------+------+-------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys                              | key               | key_len | ref  | rows  | filtered | Extra       |
    +----+-------------+-------+------------+-------+--------------------------------------------+-------------------+---------+------+-------+----------+-------------+
    |  1 | SIMPLE      | seats | NULL       | range | idx_concert_schedule_id, idx_status_cs_id  | idx_status_cs_id  | 9       | NULL |     2 |   100.00 | Using where |
    +----+-------------+-------+------------+-------+--------------------------------------------+-------------------+---------+------+-------+----------+-------------+
    ```
    - 인덱스를 사용 (type: ref) 하여 빠르게 결과를 찾을 수 있다.
    - 인덱스를 적용 후 조회하는 rows 가 28개로 줄었다.

<br>

## 1.4 WalletService

### 1.4.1 사용자 잔액 조회 쿼리
```Java
WalletRepository.findByUserId(Long userId)
```
- 기능 : 사용자 Id 로 잔액을 조회한다.

- 실제 생성되는 SQL
    ```sql
    SELECT b.* FROM balance b WHERE b.user_id = ?
    ```

- 인덱스가 필요해 보이는 이유
  - 사용자별로 잔액 조회가 빈번하게 일어날 것으로 예상된다.
  - 결제 과정, 잔액 확인 등 다양한 비즈니스 로직에서 자주 사용될 가능성이 높다.
  - 사용자 수가 증가함에 따라 테이블 크기가 커질 것이므로, 인덱스 없이는 성능 저하가 예상된다.

- 인덱스 적용 : `user.id` 
  - Cardinality 고려:
    - `user_id` 컬럼은 높은 Cardinality를 가질 것으로 예상된다. 각 사용자는 고유한 Id를 가지므로, 이 컬럼의 값들은 매우 다양할 것이다.
    - 높은 Cardinality는 인덱스 효율성을 크게 향상시킨다. 데이터베이스는 인덱스를 통해 특정 사용자를 빠르게 찾을 수 있다.
    - 이는 B-트리 인덱스의 장점을 최대한 활용할 수 있게 해주어, 검색 성능을 크게 개선해준다.


- JPA 를 사용 한 방법
  ```Java
  @Entity
  @Table(name = "wallets", indexes = @Index(columnList = "user_id"))
  public class Wallet {
      ...
  }
  ```
  - DB 에 직접 인덱스를 적용하는 방법
    ```sql
    CREATE INDEX idx_user_id ON wallets (user_id);
    ```

- 인덱스 적용으로 인한 기대효과 :
  - 잔액 조회 성능이 크게 향상될 것으로 기대된다.
  - 특히 대량의 데이터에서 특정 사용자의 잔액을 빠르게 조회할 수 있게 될 것으로 기대한다.


- 인덱스 적용 전과 후의 결과
  ```sql
  # 인덱스 적용 전
  +----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
  +----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  |  1 | SIMPLE      | balance | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 5      |    10.00 | Using where |
  +----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
  ```
  - 전체 테이블 스캔 (type: ALL) 을 수행한다.
  - 조회해야 할 rows 가 5 개다. 

  ```sql
  # 인덱스 적용 후
  +----+-------------+---------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra       |
  +----+-------------+---------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
  |  1 | SIMPLE      | balance | NULL       | ref  | idx_user_id   | idx_user_id | 8       | const |    1 |   100.00 | Using index |
  +----+-------------+---------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
  ```

  - 인덱스를 사용 (type: ref) 하여 빠르게 결과를 찾을 수 있다.
  - 조회해야 할 rows 가 1개로 줄었다.

<br>
  
### 1.1.6 기대되는 전체적인 성능 향상 

성능 향상 예상 수치:
- 인덱스 적용 전: O(n) - 전체 테이블 스캔
- 인덱스 적용 후: O(log n) - B-트리 인덱스 검색
- 예상 개선율: 약 85-95%의 쿼리 시간 감소 예상
  - (예: 100만 건 예약 데이터 기준, 인덱스 없이 1초 -> 인덱스 적용 후 50ms 이하)

<br>


## 2. 인덱스가 필요하지 않아 보이는 쿼리

위의 내용과는 다르게, 인덱스가 따로 필요하지 않은 쿼리들에 대해서도 분석해보았다.


### 1.2.1 기본 CRUD 작업

- 대상 쿼리
  - 모든 서비스의 기본 CRUD 작업

- 인덱스가 필요하지 않은 이유
  1. `JpaRepository` 최적화: Spring Data JPA의 JpaRepository 인터페이스는 이미 기본적인 CRUD 작업에 대해 최적화되어 있기 때문에 기본 작업에 있어서는 인덱스가 불필요하다.
  2. 단일 레코드 접근: findById(), save(), delete() 등의 메서드는 주로 단일 레코드에 대한 작업을 수행하므로, 추가 인덱스 없이도 효율적으로 동작한다.

### 1.2.2 기본키(PK)를 파라미터로 받는 쿼리

- 대상 쿼리
  - 모든 서비스의 쿼리 중 기본키(PK)를 파라미터로 받는 쿼리

- 인덱스가 필요하지 않은 이유
    1. 기본키 (PK) 자동 인덱싱: `JPA`에서 `@Id`로 지정된 필드는 자동으로 기본키가 되며, 대부분의 데이터베이스에서 기본키에는 자동으로 인덱스가 생성되기 때문에 불필요하다.

### 1.2.3 콘서트 목록 조회 쿼리
- 대상 쿼리
```Java
ConcertRepository.findAll(Specification<Concert> spec, Pageable pageable)
```

- 기능: 검색 조건에 맞는 콘서트 목록을 조회한다.

- 실제 생성되는 SQL:
  ```sql
  SELECT c.* 
  FROM Concert c 
  WHERE c.title LIKE ?
  AND (c.startDate BETWEEN ? AND ?)
  ORDER BY c.startDate DESC
  LIMIT 10 OFFSET 0;
  ```
- 인덱스가 필요하지 않은 이유
    - 처음에는 당연하게 인덱스를 사용해야 하는 쿼리로 생각하고 실제로 인덱스까지 적용했으나 인덱스가 필요없음을 깨닫고 인덱스가 필요하지 않은 쿼리 파트를 쓰게 한 이유가 됐다.
    - Cardinality 차원에서도 조회 빈도 수 차원에서도 분명히 인덱스가 필요한 쿼리인 것으로 판단했다
    - 그러나 결정적으로 검색기능이기 때문에 LIKE 절의 파라미터로 `%title%`이 입력되어야 하는데 LIKE절을 사용할 때 인덱스가 작동하지 않는 조건이 있었다.
        - `LIKE %title`: title로 끝나는 데이터
        - `LIKE %title%`: title이 포함되는 데이터
    - 이는 인덱스가 시작 값으로 데이터를 조회하는 B-TREE 방식을 사용하기 때문으로 `%title%`, `%title`은 기준을 잡을 수 없기 때문에 풀스캔으로 검색을 하게 된다.


## 2. 결론

본 분석을 통해 콘서트 대기열 시스템의 주요 쿼리들에 대한 인덱스 적용 방안을 검토했다.
주요 결론은 다음과 같다.

1. 성능 개선
  - 각각의 서비스들의 주요 쿼리에 대해 적절한 인덱스를 적용함으로써, 예상 쿼리 실행 시간을 85-95% 감소시킬 수 있을 것으로 기대한다.
  - 특히 사용자 잔액 조회, 콘서트 스케줄 조회, 좌석 조회 등 빈번하게 사용되는 쿼리의 성능이 크게 향상될 것으로 예상된다.

2. Cardinality 고려
  - 대부분의 제안된 인덱스는 높은 Cardinality를 가진 컬럼에 적용되어, 인덱스의 효율성을 극대화할 수 있다.
  - 예약 가능한 좌석 수 조회 쿼리의 경우, 복합 인덱스를 통해 낮은 Cardinality와 높은 Cardinality 컬럼을 조합하여 최적의 성능을 도출할 수 있다.

3. 시스템 영향
  - 인덱스 적용으로 인한 약간의 쓰기 성능 저하가 있을 수 있으나, 읽기 작업의 대폭적인 성능 향상으로 상쇄될 것으로 예상된다.
  - 읽기 작업이 대부분의 쿼리 호출의 비중을 차지하므로 전체적인 시스템 응답 시간과 사용자 경험이 크게 개선될 것으로 기대된다.

이러한 인덱스 최적화 전략을 통해 콘서트 대기열 시스템의 전반적인 성능과 확장성이 크게 개선될 것으로 예상된다.
사용자들은 더 빠른 응답 시간과 안정적인 서비스를 경험할 수 있을 것으로 기대된다.


<br>



